/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-msoffice-crypt.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : msoffice crypt
 #	author : miyako
 #	2021/11/01
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-msoffice-crypt.h"

#pragma mark -

inline cybozu::String16 fromUniHex(const std::string& str)
{
    const size_t n = str.size();
    if ((n % 5) != 0) throw cybozu::Exception("f8romUniHex:bad str") << str;
    cybozu::String16 ret;
    for (size_t i = 0; i < n; i += 5) {
        if (str[i] != 'u') throw cybozu::Exception("fromUniHex:bad format") << str;
        cybozu::Char16 c = static_cast<uint16_t>(cybozu::hextoi(&str[i + 1], 4));
        ret += c;
    }
    return ret;
}

const char denySuffixTbl[][8] = {
    "xls",
    "xlt",
    "xla",

    "ppt",
    "pot",
    "pps",
    "ppa",

    "doc",
    "dot",
};

static bool denySuffix(const std::string& suf)
{
    for (size_t i = 0; i < CYBOZU_NUM_OF_ARRAY(denySuffixTbl); i++) {
        if (suf == denySuffixTbl[i]) return true;
    }
    return false;
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- msoffice crypt
            
			case 1 :
                msoffice_crypt(params, 1);
				break;
			case 2 :
                msoffice_crypt(params, 0);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

static void msoffice_crypt(PA_PluginParameters params, int enc) {

    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_BLOB Param1;
    Param1.fromParamAtIndex(pParams, 1);
    
    cybozu::String16 wpass;
    std::string secretKey;
    /*
    bool putSecretKey = false;
    bool putEncryptionInfo = false;
    bool debug2 = false;
    bool debug3 = false;
     */
    int encMode = 0;
    int spinCount = 0;

#if VERSIONMAC
    std::string outFile;
#else
    std::wstring outFile;
#endif
    
    PA_ObjectRef status = PA_CreateObject();
    ob_set_b(status, L"success", false);
    
    PA_ObjectRef options = PA_GetObjectParameter(params, 2);
    if(options) {
        
        /*
         
         options:
         
         password > password_hex > password_uni
         secret > secret_hex > secret_uni
         mode
         
         */
        
        CUTF16String password;
        if(ob_get_a(options,L"password", &password)){
            wpass = (const cybozu::Char16 *)password.c_str();
        }
        
        CUTF8String password_hex;
        if(ob_get_s(options,L"password_hex", &password_hex)){
            wpass = cybozu::ToUtf16(ms::fromHex((const char *)password_hex.c_str()));
        }
        
        CUTF8String password_uni;
        if(ob_get_s(options,L"password_uni", &password_uni)){
            wpass = fromUniHex((const char *)password_uni.c_str());
        }
        
        CUTF8String secret;
        if(ob_get_s(options,L"secret", &secret)){
            secretKey = (const char *)secret.c_str();
        }
        
        CUTF8String secret_hex;
        if(ob_get_s(options,L"secret_hex", &secret_hex)){
            secretKey = ms::fromHex((const char *)secret_hex.c_str(), true);
        }
        
        CUTF8String secret_uni;
        if(ob_get_s(options,L"secret_uni", &secret_uni)){
            secretKey = cybozu::ToUtf8(fromUniHex((const char *)secret_uni.c_str()));
        }
        
        switch ((int)ob_get_n(options, L"mode")) {
            case 1:
                encMode = 1;//AES256
                break;
            default:
                encMode = 0;//AES128
                break;
        }
        
        /*
        putSecretKey = ob_get_b(options, L"putSecretKey");
        putEncryptionInfo = ob_get_b(options, L"putEncryptionInfo");
        debug2 = ob_get_b(options, L"debug2");
        debug3 = ob_get_b(options, L"debug3");
        ms::setDebug(debug3 ? 3 : debug2 ? 2 : putEncryptionInfo ? 1 : 0);
        if(ob_is_defined(options, L"spinCount")){
            int _spinCount = ob_get_n(options, L"spinCount");
            if(_spinCount > 0) {
                spinCount = _spinCount;
            }
        }
         */
/*
        CUTF16String path;
        if(ob_get_a(options, L"output", &path)) {
#if VERSIONMAC
            C_TEXT t;
            t.setUTF16String(path.c_str(), (uint32_t)path.length());
            CUTF8String u;
            t.copyPath(&u);
            outFile = (const char *)u.c_str();
#else
            outFile = (const wchar_t *)u.c_str();
#endif
        }
*/

    }

    const std::string passData = ms::Char16toChar8(wpass);
    
    /*
     if (putSecretKey) {
         ms::putSecretKeyInstance() = true;
     }
     */

    ms::Format format;
    
    try {
        format = ms::DetectFormat((const char *)Param1.getBytesPtr(), Param1.getBytesLength());
    } catch (std::exception& e) {
        format = ms::fUnknown;
        ob_set_s(status, L"format", "unknown");
        ob_set_s(status, L"error", e.what());
    }
    
    if (!passData.empty()) {
        
        if(enc == 1) {
            
            if (format == ms::fCfb) {
                ob_set_s(status, L"warning", "already encrypted");
            }
            
            bool isOffice2013 = encMode == 1;
            ob_set_b(status, L"isOffice2013", isOffice2013);
            
            std::string encData;
            
            bool success = ms::encode((const char *)Param1.getBytesPtr(),
                                      Param1.getBytesLength(),
                                      outFile,
				encData,
                                      passData,
                                      isOffice2013,
                                      secretKey,
                                      spinCount);
            
            ob_set_b(status, L"success", success);
            
            if(success) {
				PA_SetBlobParameter(params, 1, (void *)encData.data(), (PA_long32)encData.size());
            }
            
        }
        
        if(enc == 0) {
            
            if (format == ms::fZip) {
                ob_set_s(status, L"warning", "already decrypted");
            }
            
			std::string decData;
            bool success = ms::decode((const char *)Param1.getBytesPtr(),
                                      Param1.getBytesLength(),
										outFile,
                                      decData,
                                      passData,
                                      secretKey,
                                      false);
            
            ob_set_b(status, L"success", success);
            
            if(success) {
				PA_SetBlobParameter(params, 1, (void *)decData.data(), (PA_long32)decData.size());
            }
        }
    }
    
    PA_ReturnObject(params, status);
}
